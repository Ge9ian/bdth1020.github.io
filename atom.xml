<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>搁浅</title>
  
  <subtitle>半岛铁盒</subtitle>
  <link href="http://bdth1020.github.io/atom.xml" rel="self"/>
  
  <link href="http://bdth1020.github.io/"/>
  <updated>2022-03-29T13:14:24.932Z</updated>
  <id>http://bdth1020.github.io/</id>
  
  <author>
    <name>GXH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022.3.29</title>
    <link href="http://bdth1020.github.io/2022/03/29/dasctf/"/>
    <id>http://bdth1020.github.io/2022/03/29/dasctf/</id>
    <published>2022-03-29T07:33:59.000Z</published>
    <updated>2022-03-29T13:14:24.932Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to 蒲公英的约定</p><p>DASCTF SU三月赛</p><h2 id="xxxxxx"><a href="#xxxxxx" class="headerlink" title="xxxxxx"></a>xxxxxx</h2><h2 id="加密dct隐写，解混淆后"><a href="#加密dct隐写，解混淆后" class="headerlink" title="加密dct隐写，解混淆后"></a>加密dct隐写，解混淆后</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ import cv2,math</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">org = cv2.imread(<span class="string">'xxxxxxx.bmp'</span>, 0)</span><br><span class="line">flag = cv2.imread(<span class="string">'xxxxxxxx.bmp'</span>, 0)</span><br><span class="line">a, b = org.shape</span><br><span class="line">x = int(a/8)</span><br><span class="line">y = int(b/8)</span><br><span class="line">fingernum = flag.shape[0] * flag.shape[1]</span><br><span class="line">r = math.ceil(fingernum/(x*y))</span><br><span class="line">org = np.float32(org)</span><br><span class="line"></span><br><span class="line">org1 = org</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(y):</span><br><span class="line">        data_dct = cv2.dct(org[8*i:8*i+8, 8*j:8*j+8])</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(r):</span><br><span class="line">            rx, ry = 4, 4</span><br><span class="line">            r1 = data_dct[rx, ry]</span><br><span class="line">            r2 = data_dct[7-rx, 7-ry]</span><br><span class="line">            detat=abs(r1-r2)</span><br><span class="line">            tmp = <span class="built_in">float</span>(detat + 100)</span><br><span class="line">            <span class="keyword">if</span> flag[i][j] == 0:</span><br><span class="line">                <span class="keyword">if</span> r1 &lt;= r2:</span><br><span class="line">                    data_dct[rx, ry] += tmp</span><br><span class="line">            <span class="keyword">if</span> flag[i][j] == 255:</span><br><span class="line">                <span class="keyword">if</span> r1 &gt;= r2:</span><br><span class="line">                    data_dct[7-rx, 7-ry] += tmp</span><br><span class="line">        org1[8*i:8*i+8, 8*j:8*j+8] = cv2.idct(data_dct)</span><br><span class="line">cv2.imwrite(<span class="string">"xxxxxx.bmp"</span>, org1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>简单的dct，可以知道8格一块然后修改dct的3和4处数据，</p><p>flag以两边大小来判断，据此写exp即可得到flag，flag图像黑白相间，</p><p>查看间隔大小猜测是asc码，解密即可得到最终flag</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ import cv2,math</span><br><span class="line">import numpy as np</span><br><span class="line">from Crypto.Util import number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">org = cv2.imread(<span class="string">'xxxxxx.bmp'</span>, 0)</span><br><span class="line">a, b = org.shape</span><br><span class="line">x = int(a/8)</span><br><span class="line">y = int(b/8)</span><br><span class="line">org = np.float32(org)</span><br><span class="line"></span><br><span class="line">org1 = org</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(y):</span><br><span class="line">        data_dct = cv2.dct(org[8*i:8*i+8, 8*j:8*j+8])</span><br><span class="line">        rx, ry = 4, 4</span><br><span class="line">        r1 = data_dct[rx, ry]</span><br><span class="line">        r2 = data_dct[7-rx, 7-ry]</span><br><span class="line">        <span class="keyword">if</span> r1 &gt; r2:</span><br><span class="line">            res.append(0)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(1)</span><br><span class="line"><span class="comment"># print(len(res))</span></span><br><span class="line"><span class="comment"># res2 = np.array(res)</span></span><br><span class="line"><span class="comment"># res2 = res2.reshape(64,64)</span></span><br><span class="line">res2 = <span class="string">''</span></span><br><span class="line">flag = 0</span><br><span class="line">count = 0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)-1):</span><br><span class="line">    <span class="keyword">if</span> res[i+1] == flag:</span><br><span class="line">        count += 1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count+=1</span><br><span class="line">        <span class="comment"># print(flag,count)</span></span><br><span class="line">        <span class="built_in">print</span>(chr(count),end=<span class="string">''</span>)</span><br><span class="line">        res2 += str(flag)*(count//40)</span><br><span class="line">        flag = res[i+1]</span><br><span class="line">        count = 0</span><br><span class="line"><span class="comment"># print(number.long_to_bytes(int(res2,2)))</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="得到flag-txt"><a href="#得到flag-txt" class="headerlink" title="得到flag.txt"></a>得到flag.txt</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e25bd92141be945cfcdd1c65bb1b9375</span><br></pre></td></tr></tbody></table></figure><h2 id="书鱼的秘密"><a href="#书鱼的秘密" class="headerlink" title="书鱼的秘密"></a>书鱼的秘密</h2><p>有个wav，010查看发现data有些不对，根据hint233，</p><p>搜了下发现存在间隔，中间有许多的00，稍微观察后得到间隔是10，</p><p>于是写脚本10位提取一下，之后发现其中的233也比较规律，</p><p>异或后得到一个倒叙的png，再倒过来即可得到一个png：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">with open(<span class="string">'1.wav'</span>,<span class="string">'rb'</span>) as fp:</span><br><span class="line">    f = bytearray(fp.read()[158:])</span><br><span class="line"></span><br><span class="line">data = bytearray()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(f)//10):</span><br><span class="line">    data += (f[i*10]^233).to_bytes(1,byteorder=<span class="string">"little"</span>)</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'res'</span>,<span class="string">'wb'</span>)</span><br><span class="line"><span class="comment"># print(data[::-1])</span></span><br><span class="line">f.write(data[::-1])</span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在蓝通道存在lsb，提取得到压缩包解压得到个</p><p>书鱼的回忆.md其中重要的是</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">226232  1  </span><br><span class="line">23442647826 1   </span><br><span class="line">528842  3</span><br><span class="line">5893626874  3</span><br><span class="line">46342   2</span><br><span class="line">6443742 1</span><br><span class="line">473323  2</span><br><span class="line">24462   1-2</span><br><span class="line">6626    2</span><br><span class="line">35426884    3</span><br><span class="line">3782867425 484632   2</span><br><span class="line">2654842    3  </span><br><span class="line">2376832    0-3</span><br><span class="line">52726      1 </span><br></pre></td></tr></tbody></table></figure><p>提取得到1912120866341-4408 (注意最后有个空格)，</p><p>md5后得到答案b80ddea112953c5f56fad46758d21ba8</p><p>不加空格就不对（，出题人的锅 ）</p><p>flag：b80ddea112953c5f56fad46758d21ba8</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.snowywar.top/?p=2994 雪殇博客</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to 蒲公英的约定&lt;/p&gt;
&lt;p&gt;DASCTF SU三月赛&lt;/p&gt;
&lt;h2 id=&quot;xxxxxx&quot;&gt;&lt;a href=&quot;#xxxxxx&quot; class=&quot;headerlink&quot; title=&quot;xxxxxx&quot;&gt;&lt;/a&gt;xxxxxx&lt;/h2&gt;&lt;h2 id=&quot;加密dc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ssh的链接</title>
    <link href="http://bdth1020.github.io/2022/03/22/pico-guixingdong/"/>
    <id>http://bdth1020.github.io/2022/03/22/pico-guixingdong/</id>
    <published>2022-03-22T07:31:42.000Z</published>
    <updated>2022-03-23T04:17:46.320Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to 夜的第七章</p><h2 id="picoctf-鬼行动原题"><a href="#picoctf-鬼行动原题" class="headerlink" title="picoctf 鬼行动原题"></a>picoctf 鬼行动原题</h2><p>Download this disk image, find the key and log into the remote machine. Note: if you are using the webshell, download and extract the disk image into /tmp not your home directory.</p><h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p>题目提示 ssh -i key_file -p 53605 <a href="mailto:ctf-player@saturn.picoctf.net">ctf-player@saturn.picoctf.net</a></p><p>也就是说 只需要得到key_file 即可</p><p>做题前需了解ssh协议的使用 可以尝试用git链接github玩玩。</p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>下载后的img放进AccessData FTK Imager进行挂载分析</p><p>在p2中找到可疑的root中的.ssh</p><p>发现了经过ed25519算法加密后的公钥和私钥</p><p>模板如下：（用私钥连接即可）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -i ed25519 -p 53605 ctf-player@saturn.picoctf.net</span><br></pre></td></tr></tbody></table></figure><h3 id="openssl加解密部分"><a href="#openssl加解密部分" class="headerlink" title="openssl加解密部分"></a>openssl加解密部分</h3><p>进入到ssh层文件夹，连接到pico指定的服务器，得到权限后ls，cat文件即可。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ </span><br><span class="line">geqian@ MINGW64 ~</span><br><span class="line">$ <span class="built_in">cd</span> /c/Users/26334/Desktop/.ssh</span><br><span class="line"></span><br><span class="line">geqian@ MINGW64 ~/Desktop/.ssh</span><br><span class="line">$ ssh -i /c/Users/26334/Desktop/.ssh/id_ed25519 -p 55070 ctf-player@saturn.picoctf.net</span><br><span class="line">...................</span><br><span class="line">ctf-player@challenge:~$ <span class="built_in">ls</span></span><br><span class="line">flag.txt</span><br><span class="line">ctf-player@challenge:~$ <span class="built_in">cat</span> flag.txt</span><br><span class="line">picoCTF{k3y_5l3u7h_75b85d71}ctf-player@challenge:~$</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="得到flag-txt"><a href="#得到flag-txt" class="headerlink" title="得到flag.txt"></a>得到flag.txt</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">picoCTF{k3y_5l3u7h_75b85d71}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to 夜的第七章&lt;/p&gt;
&lt;h2 id=&quot;picoctf-鬼行动原题&quot;&gt;&lt;a href=&quot;#picoctf-鬼行动原题&quot; class=&quot;headerlink&quot; title=&quot;picoctf 鬼行动原题&quot;&gt;&lt;/a&gt;picoctf 鬼行动原题&lt;/h2&gt;&lt;p&gt;Do</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>openssl命令加解密</title>
    <link href="http://bdth1020.github.io/2022/03/22/cipanlanghua/"/>
    <id>http://bdth1020.github.io/2022/03/22/cipanlanghua/</id>
    <published>2022-03-22T07:23:06.000Z</published>
    <updated>2022-03-23T04:06:52.737Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to 兰亭集序</p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>Download this disk image and find the flag. Note: if you are using the webshell, download and extract the disk image into /tmp not your home directory.</p><h2 id="picoctf-兰花行动-准备阶段"><a href="#picoctf-兰花行动-准备阶段" class="headerlink" title="picoctf 兰花行动 准备阶段"></a>picoctf 兰花行动 准备阶段</h2><p>下载img磁盘，发现需要磁盘分析，挂载进AccessData FTK Imager。发现在Partithon3中root文件夹中还有个root，打开分析。</p><h3 id="root内文件"><a href="#root内文件" class="headerlink" title="root内文件"></a>root内文件</h3><p>有一个flag.txt.enc文件和使用记录</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> flag.txt</span><br><span class="line">nano flag.txt </span><br><span class="line">apk get nano</span><br><span class="line">apk --<span class="built_in">help</span></span><br><span class="line">apk add nano</span><br><span class="line">nano flag.txt </span><br><span class="line">openssl</span><br><span class="line">openssl aes256 -salt -<span class="keyword">in</span> flag.txt -out flag.txt.enc -k unbreakablepassword1234567</span><br><span class="line"><span class="built_in">shred</span> -u flag.txt</span><br><span class="line"><span class="built_in">ls</span> -al</span><br><span class="line">halt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="openssl加解密部分"><a href="#openssl加解密部分" class="headerlink" title="openssl加解密部分"></a>openssl加解密部分</h3><p>发现命令 openssl aes256 -salt -in flag.txt -out flag.txt.enc -k unbreakablepassword1234567<br>导出falg.txt.enc包 ，进入kali反解。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl aes256 -d -salt -<span class="keyword">in</span> flag.txt.enc -out flag.txt -k unbreakablepassword1234567</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="得到flag-txt"><a href="#得到flag-txt" class="headerlink" title="得到flag.txt"></a>得到flag.txt</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">picoCTF{h4un71ng_p457_1d02081e}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to 兰亭集序&lt;/p&gt;
&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h2&gt;&lt;p&gt;Download this disk image and find the flag. Not</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文件多层嵌套（压缩包）</title>
    <link href="http://bdth1020.github.io/2022/03/22/pico-pdf/"/>
    <id>http://bdth1020.github.io/2022/03/22/pico-pdf/</id>
    <published>2022-03-22T06:39:15.000Z</published>
    <updated>2022-03-23T04:13:24.183Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to 半岛铁盒</p><h2 id="picoctf-Flag-pdf"><a href="#picoctf-Flag-pdf" class="headerlink" title="picoctf Flag-pdf"></a>picoctf Flag-pdf</h2><p>This file was found among some files marked confidential but my pdf reader cannot read it, maybe yours can. You can download the file from here.</p><p>hint:(请记住，某些文件类型可以包含和嵌套其他文件<br>分析pdf发现存在shell脚本，使用file命令结合sh命令发现有ar包 解压ar包发现有cpio)</p><h3 id="进入kali分析shell脚本"><a href="#进入kali分析shell脚本" class="headerlink" title="进入kali分析shell脚本"></a>进入kali分析shell脚本</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ ┌──(feng02㉿kali)-[~]</span><br><span class="line">└─$ file file.            </span><br><span class="line">file.: cannot open `file.<span class="string">' (No such file or directory)</span></span><br><span class="line"><span class="string">                                                                           </span></span><br><span class="line"><span class="string">┌──(feng02㉿kali)-[~]</span></span><br><span class="line"><span class="string">└─$ file Flag.pdf</span></span><br><span class="line"><span class="string">Flag.pdf: cannot open `Flag.pdf'</span> (No such file or directory)</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~]</span><br><span class="line">└─$ file /home/feng02/桌面/Flag.pdf       </span><br><span class="line">/home/feng02/桌面/Flag.pdf: shell archive text</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~]</span><br><span class="line">└─$ sh /home/feng02/桌面/Flag.pdf       </span><br><span class="line">x - created lock directory _sh00046.</span><br><span class="line">x - extracting flag (text)</span><br><span class="line">x - removed lock directory _sh00046.</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~]</span><br><span class="line">└─$ file flag                      </span><br><span class="line">flag: current ar archive</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~]</span><br><span class="line">└─$ ar x flag</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~]</span><br><span class="line">└─$ file flag</span><br><span class="line">flag: cpio archive</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="多层嵌套解包"><a href="#多层嵌套解包" class="headerlink" title="多层嵌套解包"></a>多层嵌套解包</h3><p>cpio需要在文件名后缀加上.cpio否则无法识别<br>之后使用cpio -i &lt; flag.cpio<br>解压后发现bzip<br>bzip命令可以用 -d解压 -k保存原来的压缩包  重复……</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ ──(feng02㉿kali)-[~/桌面]</span><br><span class="line">└─$ file flag</span><br><span class="line">flag: lzop compressed data - version 1.040, LZO1X-1, os: Unix</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~/桌面]</span><br><span class="line">└─$ lzop -d flag     </span><br><span class="line">lzop: flag: unknown suffix -- ignored</span><br><span class="line">skipping flag [flag.raw]</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~/桌面]</span><br><span class="line">└─$ lzop -d flag.lzop                                                  1 ⨯</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~/桌面]</span><br><span class="line">└─$ file flag</span><br><span class="line">flag: lzip compressed data, version: 1</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~/桌面]</span><br><span class="line">└─$ lzip -d flag     </span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~/桌面]</span><br><span class="line">└─$ file flag.out</span><br><span class="line">flag.out: XZ compressed data, checksum CRC64</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~/桌面]</span><br><span class="line">└─$ xz -d flag.out</span><br><span class="line">xz：flag.out：文件名有未知后缀，跳过</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~/桌面]</span><br><span class="line">└─$ xz -d flag.xz                                                      2 ⨯</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~/桌面]</span><br><span class="line">└─$ file flag    </span><br><span class="line">flag: ASCII text</span><br><span class="line">                                                                           </span><br><span class="line">┌──(feng02㉿kali)-[~/桌面]</span><br><span class="line">└─$ <span class="built_in">cat</span> flag </span><br><span class="line">7069636f4354467b66316c656e406d335f6d406e3170756c407431306e5f</span><br><span class="line">6630725f3062326375723137795f39353063346665657d0a</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>大概十多个包后可以得到ascii text</p><h3 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h3><p>cat flag之后很明显得到一串16进制码  转字符就可以得到flag</p><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">picoCTF{f1len@m3_m@n1pul@t10n_f0r_0b2cur17y_950c4fee}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to 半岛铁盒&lt;/p&gt;
&lt;h2 id=&quot;picoctf-Flag-pdf&quot;&gt;&lt;a href=&quot;#picoctf-Flag-pdf&quot; class=&quot;headerlink&quot; title=&quot;picoctf Flag-pdf&quot;&gt;&lt;/a&gt;picoctf Flag-pd</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>测信道攻击</title>
    <link href="http://bdth1020.github.io/2022/03/22/dingshigouji/"/>
    <id>http://bdth1020.github.io/2022/03/22/dingshigouji/</id>
    <published>2022-03-22T02:37:48.639Z</published>
    <updated>2022-03-23T04:04:47.796Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to<br>搁浅</p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>There’s something fishy about this PIN-code checker, can you figure out the PIN and get the flag? Download the PIN checker program here pin_checker Once you’ve figured out the PIN (and gotten the checker program to accept it), connect to the master server using nc saturn.picoctf.net 50364 and provide it the PIN to get your flag.</p><h2 id="定时攻击"><a href="#定时攻击" class="headerlink" title="定时攻击"></a>定时攻击</h2><p>在定时攻击中，攻击者试图通过分析执行密码算法所花费的时间来破坏密码系统。因为计算机中的每个逻辑操作都需要时间来执行，并且时间可能因输入而异，所以通过精确测量每个操作的时间，攻击者可以回溯到输入。通过时间信息发现秘密可能比使用已知明文、密文对的密码分析要容易得多。有时，时序信息与密码分析相结合，以增加信息泄漏率。</p><p>例如模幂运算中使用的平方和乘法算法的执行时间线性地取决于密钥中“1”位的数量。虽然“1”位的数量不足以使找到密钥变得容易，但使用相同的密钥和不同的输入重复执行可用于执行时序信息的统计相关性分析以完全恢复密钥，即使通过被动攻击者。</p><p>但是需要注意到的是，观察到的时序测量通常包括噪声（来自诸如网络延迟、访问与访问之间的磁盘驱动器访问差异以及用于从传输错误中恢复的纠错技术等来源）。</p><p>当然，定时攻击对许多加密算法是实用的，包括 RSA、ElGamal 和数字签名算法。</p><h3 id="定时攻击基础的思路"><a href="#定时攻击基础的思路" class="headerlink" title="定时攻击基础的思路"></a>定时攻击基础的思路</h3><p> 此时 有一个不安全的密码验证函数</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ bool insecureStringCompare(const char* a, const char* b, size_t length)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (size_t i = 0; i &lt; length; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (a[i] != b[i])</span><br><span class="line">{</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="依据本题写python脚本"><a href="#依据本题写python脚本" class="headerlink" title="依据本题写python脚本"></a>依据本题写python脚本</h3><p>基于时间差的长短判断密码是否正确，循环反复判断。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ import pwn</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def run(arg:str):</span><br><span class="line">    io = pwn.process(<span class="string">"/home/feng02/桌面/pin_checker.py"</span>) <span class="comment">#本地运行一个程序</span></span><br><span class="line">    <span class="built_in">print</span>(io.recv())    <span class="comment">#接收所有数据</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    io.sendline(arg.encode()) <span class="comment">#发送arg数据并以bytes输出 且包含换行符</span></span><br><span class="line">    io.recvall()  <span class="comment">#接收所有数据，直到socket关闭</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    io.close()</span><br><span class="line">    <span class="built_in">return</span> end - start</span><br><span class="line"></span><br><span class="line">result = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(8):</span><br><span class="line">    t = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(10):</span><br><span class="line">        ret = run(result + str(j) + <span class="string">"0"</span> * (7 - i))</span><br><span class="line">        t.append(ret)</span><br><span class="line">    result += str(t.index(max(t)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f<span class="string">"PIN: {result}"</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ 侧信道攻击一般类别包括：</span><br><span class="line"></span><br><span class="line">缓存攻击 → 攻击基于攻击者监控受害者在共享物理系统（如在虚拟化环境或某种云服务中）进行的缓存访问的能力。</span><br><span class="line">定时攻击 → 基于测量各种计算（例如，将攻击者的给定密码与受害者的未知密码进行比较）执行的时间的攻击。</span><br><span class="line">电源监控攻击 → 在计算过程中利用硬件不同功耗的攻击。</span><br><span class="line">电磁攻击 → 基于泄露的电磁辐射的攻击，可以直接提供明文等信息。此类测量可用于使用与功率分析中的技术等效的技术来推断密码密钥，或者可用于非密码攻击。</span><br><span class="line">声学密码分析 → 利用计算过程中产生的声音的攻击（类似于功率分析）。</span><br><span class="line">差分故障分析 → 通过在计算中引入故障来发现秘密。</span><br><span class="line">数据残留 → 敏感数据在被删除后被读取。</span><br><span class="line">软件发起的故障攻击 → 目前是一种罕见的侧通道，Row_hammer是一个示例</span><br><span class="line">光学 → 可以使用高分辨率相机或其他具有此类功能的设备，通过视觉记录来读取机密和敏感数据。</span><br></pre></td></tr></tbody></table></figure><h3 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ https://hasegawaazusa.github.io/</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to&lt;br&gt;搁浅&lt;/p&gt;
&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h2&gt;&lt;p&gt;There’s something fishy about this PIN-code ch</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>P2P通信协议</title>
    <link href="http://bdth1020.github.io/2022/03/21/hongliufenxi/"/>
    <id>http://bdth1020.github.io/2022/03/21/hongliufenxi/</id>
    <published>2022-03-21T07:39:28.991Z</published>
    <updated>2022-03-23T04:10:44.937Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to 枫</p><h2 id="pico洪流分析"><a href="#pico洪流分析" class="headerlink" title="pico洪流分析"></a>pico洪流分析</h2><p>SOS, someone is torrenting on our network. One of your colleagues has been using torrent to download some files on the company’s network. Can you identify the file(s) that were downloaded? The file name will be the flag, like picoCTF{filename}. Captured traffic.</p><h2 id="BitTorrent协议"><a href="#BitTorrent协议" class="headerlink" title="BitTorrent协议"></a>BitTorrent协议</h2><p>要理解下面的内容之前，首先要知道什么是 BitTorrent</p><p>BitTorrent 是一种点对点（P2P, Peers to Peers）的通信协议，用于在互联网上分发大量的数据和电子文件，包括但不限于数字视频文件或者歌曲文件。</p><p>而点对点（P2P, Peers to Peers）网络是指仅两台或多台 PC 连接并共享资源而无需通过单独的服务器的用户网络。</p><p>BitTorrent 协议可用于减少分发大文件对服务器和网络的影响。BitTorrent 协议不是从单个源服务器下载文件，而是允许用户加入主机“群”（一群人下载和上传相同的文件），以同时从彼此下载和上传。</p><p>使用 BitTorrent 协议，几台基本计算机（例如家用计算机）可以取代大型服务器，同时有效地将文件分发给许多收件人。这种较低的带宽使用量还有助于防止给定区域的互联网流量大幅飙升，从而为所有用户保持更高的互联网速度，无论他们是否使用 BitTorrent 协议。</p><p>###种子文件与磁力链接<br>在很早的网络时代，下载都是简单的集中式客户端/服务器模式，一个或多个服务器支撑成千上万的客户端连接下载，不仅带宽遇到了瓶颈，而且太容易出现单点故障。这时 P2P 被提出来解决这个问题，通过分布式提高网络资源的利用率。但是 P2P 只是一个理念，真正将这个理念贯彻的还是 BitTorrent 协议。</p><p>在 BitTorrent （简称 BT）中，所有的资源被切成很小的一份文件块（pieces），在这个基础上，BitTorrent 网络中的所有具有相同请求的用户可以相互传资源碎片，并且谁传得越多谁就能获得越多。</p><p>而种子文件，就是拥有完整资源的人，根据 BitTorrent 协议，生成的一个包含 Tracker 信息和文件信息的文本文件。</p><p>Tracker 信息主要是BT下载中需要用到的 Tracker 服务器的地址和针对 Tracker 服务器的设置，文件信息是根据对目标文件的计算生成的，计算结果根据 BitTorrent 协议内的 Bencode 规则进行编码。它的主要原理是需要把提供下载的文件虚拟分成大小相等的块，块大小必须为2k的整数次方（由于是虚拟分块，硬盘上并不产生各个块文件），并把每个块的索引信息和 Hash 验证码写入种子文件中；所以，种子文件就是被下载文件的索引。</p><p>下载者要下载文件内容，需要先得到相应的种子文件，然后使用 BT 客户端软件进行下载。 下载时，BT 客户端首先解析种子文件得到 Tracker 地址，然后连接 Tracker 服务器。Tracker 服务器回应下载者的请求，提供下载者其他下载者（包括发布者）的 IP。</p><p>下载者再连接其他下载者，根据种子文件，两者分别告知对方自己已经有的块，然后交换对方所没有的数据。此时不需要其他服务器参与，分散了单个线路上的数据流量，因此减轻了服务器负担。 下载者每得到一个块，需要算出下载块的 Hash 验证码与种子文件中的对比，如果一样则说明块正确，不一样则需要重新下载这个块。</p><p>与此同时，当拥有完整文件的用户越多，种子的寿命也就越长。</p><p>综上所述，可以看出 Tracker 服务器在BT网络中充当着非常重要的作用，和传统的客户端/服务器模式一样，Tracker 服务器同样会存在单点故障问题。所以在BT技术的基础上，后来又衍生出 DHT 网络和磁力链接技术，DHT 全称为分布式哈希表（Distributed Hash Table），是一种分布式存储方法。</p><p>DHT 网络是 Tracker-less 的，不依赖于其他的 Tracker 服务器。在这种情况下，每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个 DHT 网络的寻址和存储。使用支持该技术的BT下载软件，用户无需连上Tracker就可以下载，因为软件会在 DHT 网络中寻找下载同一文件的其他用户并与之通讯，开始下载任务。</p><p>在网络中定位资源最简单的方法是URL（统一资源定位符），它是通过资源的位置来进行定位。而在DHT网络中，则是使用URN（统一资源名称）来进行定位，磁力链接就是基于文件内容的散列函数值来链接到特定文件，生成一个唯一的文件识别符，从而在DHT网络中定位并下载文件。</p><p>磁力链接格式如下所示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ magnet:?xt=urn:btih:e2467cbf021192c241367b892230dc1e05c0580e</span><br></pre></td></tr></tbody></table></figure><p>其中 urn 为统一资源名称，bith 是 BitTorrent Info Hash 的缩写，是 BitTorrent 使用的 Hash 函数。</p><h3 id="KRPC-协议"><a href="#KRPC-协议" class="headerlink" title="KRPC 协议"></a>KRPC 协议</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ DHT 建立在 UDP 之上，想要获取需要的 Peers 信息，首先要了解下 Kademlia 的 KRPC 协议。 关于路由表和 Kademlia 的介绍，可以参照官方文档。我们这里的重点在于如何根据磁力链接获取拥有该磁力链接对应的种子文件信息的 Peers，所以只需要了解 KRPC 协议。 KRPC 协议是由 Bencoding 编码组成的一个简单的 RPC 结构，有4种请求：ping、find_node、get_peers 和 announce_peer。</span><br><span class="line"></span><br><span class="line">ping → 检测节点是否可达，请求包含一个参数 <span class="built_in">id</span>，代表该节点的 <span class="built_in">id</span>。对应的回复也应该包含回复者的<span class="built_in">id</span>。</span><br><span class="line">find_node → 该请求包含两个参数 <span class="built_in">id</span> 和 target，<span class="built_in">id</span> 为该节点的 <span class="built_in">id</span>，target 为要查询的 <span class="built_in">id</span>。回复中应该包含被请求节点的路由表中距离 target 最接近的 8 个 <span class="built_in">id</span>。</span><br><span class="line">get_peers → 该请求包含两个参数 <span class="built_in">id</span> 和 infohash，<span class="built_in">id</span> 为该节点的 <span class="built_in">id</span>，info_hash 为种子文件的SHA1哈希值，也就是磁力链接的 btih 值。如果被请求的节点有对应 info_hash 的 peers，他将返回一个关键字 values，这是一个列表类型的字符串。每一个字符串包含了 CompactIP-address/portinfo 格式的peers信息。如果被请求的节点没有这个 infohash 的 peers，那么他将返回关键字 nodes，这个关键字包含了被请求节点的路由表中离 info_hash 最近的 K 个 nodes，使用 Compactnodeinfo 格式回复。</span><br><span class="line">announce_peer → 如果节点正在下载 torrent 文件，则需要通知其他人你正在哪个端口进行下载，这样就可以分享给其他人，让其他人连接你进行下载。</span><br></pre></td></tr></tbody></table></figure><p>种子文件格式：<br>BT种子文件整个是一个 Bencoding 编码字典格式，比较重要的 key 有：</p><p>announce → tracker 服务器的地址<br>announce-list → 可选的 tracker 服务器地址<br>creation date → 文件创建时间<br>created by → 文件创建者<br>info → BT 种子文件的文件信息<br>而 info 的 value 会根据种子包含的是单文件还是多文件有所区别，以下是公共部分：</p><p>piece length → 每一数据块的长度<br>pieces → 所有数据块的 SHA1 校验值<br>如果种子包含的是单文件，则还有以下 key</p><p>name → 文件名称<br>length → 文件的长度<br>如果包含的是多文件，则是以下 key</p><p>name → 文件夹名称<br>files → 文件列表，每个文件列表下面是包括每一个单文件的信息，文件信息是个字典<br>而 info 中的内容是种子文件中的重中之重，在 DHT 网络中保留的内容就是 info 字段的内容。</p><p>而磁力链接中的 infohash 便是根据 info 字段的内容计算的，info 字段的 pieces 字段为每个数据块的校验值，作用便是验证下载的文件是否正确。</p><p>要注意的是 info字段的下载也是分块的下载完成后使用 infohash 进行校验。</p><p>所以，我们可以知道，磁力链接下载文件分成两个步骤：</p><p>根据 infohash 下载种子文件的 info 字段，注意到种子文件并不是必须的。<br>再根据 info 下载源文件，将每一个数据块进行校验，不一致则重新下载。<br>需要注意的是，一般的种子文件会包含 announce，也就是 tracker 服务器的地址，如果没有 tracker 服务器，文件中可能会包含 nodes，nodes 是存有种子信息的 peer 节点，这样的种子文件就是 trackerless torrent。如果有 nodes 客户端直接从 nodes 获取种子信息，而从 DHT 网络中下载下来的种子文件既没有 annouce 也没有 nodes，客户端只能通过 info 字段计算出 hashinfo，再从 bootstrap node 节点开始在 DHT 网络中寻找种子信息。</p><h3 id="流量分析原题"><a href="#流量分析原题" class="headerlink" title="流量分析原题"></a>流量分析原题</h3><p>BT流量一般会出现几个包，一个是uTP，这个是传输数据的，一个是DHT，是一个网络包用来发各种请求的，请求包括ping、find_node，get_peers等等。get_peers的包里，会有一个数据叫info_hash的，它对应的值就是要找的种子btih值，也就是magnet:?xt=urn:btih:后面的那一堆东西，用迅雷，直接复制那一段值，会自动获取种子，找到ios后缀种子即可！<br>过滤代码如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bt-dht.bencoded.string == <span class="string">"get_peers"</span> and ip.src == 192.168.73.132 and bt-dht</span><br></pre></td></tr></tbody></table></figure><p>找到find_node对应的值后，进入迅雷软件寻找种子文件，经过尝试找到以.ios为后缀的名字为flag{filename}</p><h3 id="出自"><a href="#出自" class="headerlink" title="出自"></a>出自</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ https://hasegawaazusa.github.io/</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to 枫&lt;/p&gt;
&lt;h2 id=&quot;pico洪流分析&quot;&gt;&lt;a href=&quot;#pico洪流分析&quot; class=&quot;headerlink&quot; title=&quot;pico洪流分析&quot;&gt;&lt;/a&gt;pico洪流分析&lt;/h2&gt;&lt;p&gt;SOS, someone is torrenting</summary>
      
    
    
    
    
  </entry>
  
</feed>
